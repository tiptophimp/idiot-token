<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IDIOT Meme Generator - AI-Powered Comedy Engine</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üß†</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 2rem;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 3rem;
            color: white;
        }
        
        header h1 {
            font-size: 3rem;
            margin-bottom: 0.5rem;
            text-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        
        header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .evolution-banner {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 2rem;
            margin-bottom: 2rem;
            text-align: center;
        }
        
        .evolution-banner img {
            max-width: 100%;
            height: auto;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
        }
        
        .panel {
            background: white;
            border-radius: 20px;
            padding: 2rem;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .panel h2 {
            color: #667eea;
            margin-bottom: 1.5rem;
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .input-group {
            margin-bottom: 1.5rem;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #555;
        }
        
        .input-group textarea {
            width: 100%;
            padding: 1rem;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            font-size: 1rem;
            font-family: inherit;
            resize: vertical;
            min-height: 100px;
            transition: all 0.3s;
        }
        
        .input-group textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .style-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .style-btn {
            padding: 1rem;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1rem;
            font-weight: 600;
            text-align: center;
        }
        
        .style-btn:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }
        
        .style-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }
        
        .generate-btn {
            width: 100%;
            padding: 1.2rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        .generate-btn:active {
            transform: translateY(0);
        }
        
        .canvas-container {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 500px;
        }
        
        #memeCanvas {
            max-width: 100%;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-top: 2rem;
        }
        
        .action-btn {
            padding: 1rem;
            border: 2px solid #667eea;
            border-radius: 12px;
            background: white;
            color: #667eea;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1rem;
        }
        
        .action-btn:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
        }
        
        .share-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            margin-top: 2rem;
        }
        
        .share-btn {
            padding: 0.8rem;
            border: none;
            border-radius: 12px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
        }
        
        .share-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 2rem;
            color: #667eea;
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .loading.active {
            display: block;
        }
        
        .processing-info {
            background: #f0f7ff;
            border-left: 4px solid #667eea;
            padding: 1rem;
            margin-top: 1rem;
            border-radius: 8px;
            font-size: 0.9rem;
            color: #555;
        }
        
        .processing-info strong {
            color: #667eea;
        }
        
        .examples {
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 1rem;
            margin-top: 1rem;
        }
        
        .examples p {
            color: white;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }
        
        .example-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .example-tag {
            background: rgba(255,255,255,0.2);
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            font-size: 0.85rem;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .example-tag:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.05);
        }
        
        @media (max-width: 968px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .style-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            header h1 {
                font-size: 2rem;
            }
            
            .evolution-banner {
                padding: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üß† IDIOT Meme Generator</h1>
            <p>AI-Powered Comedy Engine - Real Intelligence, Real Laughs!</p>
        </header>
        
        <div class="evolution-banner">
            <img src="../assets/idiot-evolution.png" alt="IDIOT Token Evolution" onerror="this.style.display='none'">
        </div>
        
        <div class="main-grid">
            <!-- Input Panel -->
            <div class="panel">
                <h2>üí≠ Your Raw Input</h2>
                
                <div class="input-group">
                    <label>What's your situation? (Be specific!)</label>
                    <textarea id="userInput" placeholder="Describe your situation, feeling, or thought... The AI will transform it into comedy gold! Examples: 'I bought crypto at the peak', 'explaining blockchain to my grandma', 'checking portfolio every 5 minutes'"></textarea>
                </div>
                
                <div class="input-group">
                    <label>Choose Your Comedy Style</label>
                    <div class="style-grid">
                        <button class="style-btn active" data-style="classic">üòÇ Classic</button>
                        <button class="style-btn" data-style="crypto">üíé Crypto</button>
                        <button class="style-btn" data-style="wholesome">ü•∞ Wholesome</button>
                        <button class="style-btn" data-style="dark">üòà Dark</button>
                        <button class="style-btn" data-style="absurd">ü§™ Absurd</button>
                        <button class="style-btn" data-style="smart">üß† Smart</button>
                    </div>
                </div>
                
                <button class="generate-btn" onclick="generateMeme()">‚ú® Transform Into Meme</button>
                
                <div class="processing-info" id="processingInfo" style="display: none;">
                    <strong>üß† AI Processing:</strong><br>
                    <span id="processingSteps"></span>
                </div>
                
                <div class="examples">
                    <p><strong>üí° Try these scenarios:</strong></p>
                    <div class="example-tags">
                        <span class="example-tag" onclick="useExample('I bought at the all-time high thinking it would go higher')">üìà Bought the top</span>
                        <span class="example-tag" onclick="useExample('trying to explain DeFi to my parents at dinner')">üë¥ Explain DeFi</span>
                        <span class="example-tag" onclick="useExample('waking up at 3am to check my portfolio')">üåô 3am check</span>
                        <span class="example-tag" onclick="useExample('sold before the pump started')">üìâ Sold early</span>
                        <span class="example-tag" onclick="useExample('my friend asking me for crypto advice')">üí¨ Crypto advice</span>
                        <span class="example-tag" onclick="useExample('waiting for my token to moon')">üöÄ Waiting to moon</span>
                    </div>
                </div>
            </div>
            
            <!-- Output Panel -->
            <div class="panel">
                <h2>üé® AI-Generated Meme</h2>
                
                <div class="canvas-container">
                    <canvas id="memeCanvas" width="800" height="800"></canvas>
                </div>
                
                <div class="loading" id="loading">
                    üß† AI is analyzing your input and generating comedy...
                </div>
                
                <div class="action-buttons">
                    <button class="action-btn" onclick="downloadMeme()">üíæ Download</button>
                    <button class="action-btn" onclick="regenerateMeme()">üîÑ Regenerate</button>
                    <button class="action-btn" onclick="copyMeme()">üìã Copy</button>
                </div>
                
                <div class="share-grid">
                    <button class="share-btn" style="background: #1DA1F2;" onclick="shareTwitter()">üê¶ Twitter</button>
                    <button class="share-btn" style="background: #0088cc;" onclick="shareTelegram()">‚úàÔ∏è Telegram</button>
                    <button class="share-btn" style="background: #FF4500;" onclick="shareReddit()">üî¥ Reddit</button>
                    <button class="share-btn" style="background: #5865F2;" onclick="shareDiscord()">üí¨ Discord</button>
                    <button class="share-btn" style="background: #25D366;" onclick="shareWhatsApp()">üì± WhatsApp</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('memeCanvas');
        const ctx = canvas.getContext('2d');
        let currentStyle = 'classic';
        let lastInput = '';
        let lastOutput = { top: '', bottom: '' };
        
        // Style button handling
        document.querySelectorAll('.style-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.style-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentStyle = this.dataset.style;
            });
        });
        
        // ============================================
        // INTELLIGENT MEME GENERATION ENGINE
        // ============================================
        
        /**
         * Main AI Processing Pipeline
         * Input goes through multiple transformation stages
         * Output is ALWAYS different from input
         */
        function intelligentMemeProcessor(rawInput, style) {
            // Stage 1: Input Analysis
            const analysis = analyzeInput(rawInput);
            
            // Stage 2: Context Understanding
            const context = extractContext(analysis);
            
            // Stage 3: Comedy Generation
            const memeText = generateComedyFromContext(context, style, rawInput);
            
            // Stage 4: Validation (ensure output != input)
            const validated = validateUniqueness(memeText, rawInput);
            
            return validated;
        }
        
        /**
         * Stage 1: Analyze the input for patterns, keywords, and sentiment
         */
        function analyzeInput(input) {
            const lower = input.toLowerCase().trim();
            
            return {
                original: input,
                lower: lower,
                words: lower.split(/\s+/),
                length: lower.length,
                sentiment: detectSentiment(lower),
                keywords: extractKeywords(lower),
                pattern: detectPattern(lower),
                tense: detectTense(lower),
                person: detectPerson(lower)
            };
        }
        
        /**
         * Detect emotional sentiment
         */
        function detectSentiment(text) {
            const positive = ['happy', 'great', 'awesome', 'amazing', 'love', 'excited', 'win', 'moon', 'profit', 'gain'];
            const negative = ['sad', 'bad', 'terrible', 'hate', 'loss', 'dump', 'crash', 'rekt', 'broke', 'poor'];
            const neutral = ['check', 'look', 'see', 'think', 'maybe', 'try', 'wait'];
            
            let score = 0;
            positive.forEach(word => { if (text.includes(word)) score += 1; });
            negative.forEach(word => { if (text.includes(word)) score -= 1; });
            
            if (score > 0) return 'positive';
            if (score < 0) return 'negative';
            return 'neutral';
        }
        
        /**
         * Extract important keywords by category
         */
        function extractKeywords(text) {
            const categories = {
                crypto: ['crypto', 'bitcoin', 'btc', 'eth', 'ethereum', 'token', 'coin', 'blockchain', 'wallet', 'hodl', 'moon', 'lambo', 'dip', 'pump', 'dump', 'bull', 'bear', 'defi', 'nft', 'trade', 'swap', 'gas', 'fee'],
                money: ['money', 'rich', 'poor', 'broke', 'cash', 'dollar', 'profit', 'loss', 'invest', 'buy', 'sell', 'price', 'value', 'worth'],
                emotion: ['happy', 'sad', 'angry', 'scared', 'excited', 'tired', 'stressed', 'anxious', 'confused', 'proud', 'shame'],
                time: ['morning', 'night', '3am', 'midnight', 'monday', 'friday', 'weekend', 'today', 'tomorrow', 'always', 'never'],
                people: ['me', 'i', 'my', 'you', 'we', 'they', 'mom', 'dad', 'parent', 'friend', 'boss', 'wife', 'husband', 'family'],
                action: ['buy', 'sell', 'check', 'look', 'wait', 'hold', 'trade', 'explain', 'tell', 'show', 'think', 'know']
            };
            
            const found = {};
            Object.keys(categories).forEach(category => {
                found[category] = categories[category].filter(word => text.includes(word));
            });
            
            return found;
        }
        
        /**
         * Detect input pattern structure
         */
        function detectPattern(text) {
            if (text.startsWith('when ') || text.includes(' when ')) return 'when';
            if (text.startsWith('me ') || text.startsWith('i ')) return 'first_person';
            if (text.includes('trying to') || text.includes('attempt')) return 'attempt';
            if (text.includes('explain') || text.includes('tell')) return 'explain';
            if (text.includes('nobody') || text.includes('no one')) return 'nobody';
            if (text.includes('waiting') || text.includes('wait')) return 'waiting';
            if (text.includes('?')) return 'question';
            return 'statement';
        }
        
        /**
         * Detect tense
         */
        function detectTense(text) {
            if (text.includes('will') || text.includes('gonna') || text.includes('going to')) return 'future';
            if (text.includes('ed ') || text.includes('was') || text.includes('were')) return 'past';
            return 'present';
        }
        
        /**
         * Detect person (1st, 2nd, 3rd)
         */
        function detectPerson(text) {
            if (text.includes('i ') || text.includes('me ') || text.includes('my ')) return 'first';
            if (text.includes('you ') || text.includes('your ')) return 'second';
            return 'third';
        }
        
        /**
         * Stage 2: Extract meaningful context from analysis
         */
        function extractContext(analysis) {
            const { keywords, sentiment, pattern, tense, person } = analysis;
            
            // Determine primary theme
            let theme = 'general';
            if (keywords.crypto.length > 0) theme = 'crypto';
            else if (keywords.money.length > 0) theme = 'money';
            else if (keywords.emotion.length > 0) theme = 'emotion';
            
            // Determine situation type
            let situation = 'generic';
            if (pattern === 'when') situation = 'conditional';
            else if (pattern === 'explain') situation = 'communication_fail';
            else if (pattern === 'attempt') situation = 'failure';
            else if (pattern === 'waiting') situation = 'anticipation';
            else if (pattern === 'nobody') situation = 'unprompted';
            
            return {
                theme,
                situation,
                sentiment,
                pattern,
                tense,
                person,
                keywords
            };
        }
        
        /**
         * Stage 3: Generate comedy based on context
         * This is where the magic happens!
         */
        function generateComedyFromContext(context, style, originalInput) {
            const { theme, situation, sentiment, pattern, keywords } = context;
            
            let topText = '';
            let bottomText = '';
            
            // RULE: Never use original input as-is
            // Always transform, reframe, or add commentary
            
            // Pattern-based generation
            if (situation === 'conditional') {
                // Transform "when X" into relatable format
                topText = transformWhenStatement(originalInput, keywords);
                bottomText = generateReaction(sentiment, style, theme);
            }
            else if (situation === 'communication_fail') {
                // Transform explanation attempts
                topText = "ME: " + generateExplanationAttempt(keywords, theme);
                bottomText = generateListenerReaction(style);
            }
            else if (situation === 'anticipation') {
                // Transform waiting scenarios
                topText = generateWaitingSetup(originalInput, keywords);
                bottomText = generateWaitingPunchline(style, theme);
            }
            else if (situation === 'unprompted') {
                // Nobody: format
                topText = "NOBODY:";
                bottomText = "ME: " + generateUnpromptedAction(keywords, theme);
            }
            else {
                // Generic transformation
                const transformed = transformGenericInput(originalInput, keywords, theme);
                topText = transformed.top;
                bottomText = transformed.bottom;
            }
            
            // Apply style modifiers
            const styled = applyStyleModifiers(topText, bottomText, style, theme);
            
            return styled;
        }
        
        /**
         * Transform "when" statements into meme format
         */
        function transformWhenStatement(input, keywords) {
            // Extract the core situation
            let core = input.replace(/^when\s+/i, '').replace(/^you\s+/i, '').trim();
            
            // Add relatable framing
            if (keywords.crypto.length > 0) {
                const frames = [
                    "POV: YOU JUST",
                    "THAT MOMENT WHEN YOU",
                    "CRYPTO TRADERS AFTER THEY",
                    "ME LITERALLY EVERY TIME I"
                ];
                return frames[Math.floor(Math.random() * frames.length)] + " " + core.toUpperCase();
            }
            
            return "THAT FEELING WHEN " + core.toUpperCase();
        }
        
        /**
         * Generate reactions based on sentiment and style
         */
        function generateReaction(sentiment, style, theme) {
            const reactions = {
                classic: {
                    positive: ["BEST DECISION EVER", "GENIUS MOVE", "CALLED IT", "EASY MONEY"],
                    negative: ["PAIN", "WHY DO I DO THIS", "EVERY SINGLE TIME", "I'M IN DANGER"],
                    neutral: ["IT BE LIKE THAT", "SUCH IS LIFE", "CLASSIC", "STORY OF MY LIFE"]
                },
                crypto: {
                    positive: ["WAGMI üöÄ", "DIAMOND HANDS ACTIVATED", "TO THE MOON", "BULLISH AF"],
                    negative: ["NGMI", "REKT", "GUH", "BEAR MARKET THINGS"],
                    neutral: ["HODL MODE", "THIS IS THE WAY", "PROBABLY NOTHING", "DYOR"]
                },
                wholesome: {
                    positive: ["YOU'RE DOING GREAT ‚ù§Ô∏è", "PROUD OF YOU", "KEEP IT UP", "WHOLESOME WIN"],
                    negative: ["IT'S OKAY, WE LEARN", "TOMORROW IS NEW DAY", "YOU TRIED YOUR BEST", "GROWTH MOMENT"],
                    neutral: ["VALID", "RELATABLE", "WE'VE ALL BEEN THERE", "SENDING GOOD VIBES"]
                },
                dark: {
                    positive: ["TEMPORARY HAPPINESS", "ENJOY IT WHILE IT LASTS", "TOO GOOD TO BE TRUE", "WHAT'S THE CATCH"],
                    negative: ["EXISTENCE IS PAIN", "SUFFERING", "NO ESCAPE", "VOID STARES BACK"],
                    neutral: ["MEANINGLESS", "NOTHING MATTERS", "EMBRACE THE CHAOS", "WELCOME TO HELL"]
                },
                absurd: {
                    positive: ["MONKE BRAIN WIN", "STONKS", "BIG BRAIN TIME", "REALITY GLITCH"],
                    negative: ["BRAIN.EXE STOPPED", "ERROR 404: LOGIC NOT FOUND", "GLITCH IN MATRIX", "SIMULATION BROKEN"],
                    neutral: ["REJECT MODERNITY", "RETURN TO MONKE", "WHAT IS REALITY", "CHAOS REIGNS"]
                },
                smart: {
                    positive: ["CALCULATED", "ACCORDING TO PLAN", "200 IQ PLAY", "GAME THEORY WINS"],
                    negative: ["MISCALCULATION", "VARIABLES CHANGED", "UNEXPECTED OUTCOME", "THEORY VS REALITY"],
                    neutral: ["OBSERVING", "DATA SUGGESTS", "HYPOTHESIS TESTING", "ANALYSIS PENDING"]
                }
            };
            
            const styleReactions = reactions[style] || reactions.classic;
            const sentimentReactions = styleReactions[sentiment] || styleReactions.neutral;
            
            return sentimentReactions[Math.floor(Math.random() * sentimentReactions.length)];
        }
        
        /**
         * Generate explanation attempts
         */
        function generateExplanationAttempt(keywords, theme) {
            if (theme === 'crypto') {
                const attempts = [
                    "*DRAWS COMPLICATED DIAGRAM*",
                    "SO BASICALLY IT'S LIKE MONEY BUT...",
                    "*USES 47 TECHNICAL TERMS*",
                    "OKAY SO IMAGINE A SPREADSHEET..."
                ];
                return attempts[Math.floor(Math.random() * attempts.length)];
            }
            
            return "*EXPLAINS PASSIONATELY FOR 20 MINUTES*";
        }
        
        /**
         * Generate listener reactions
         */
        function generateListenerReaction(style) {
            const reactions = {
                classic: ["THEM: üòê", "THEM: I DON'T GET IT", "THEM: *BLANK STARE*", "THEM: THAT'S NICE DEAR"],
                crypto: ["THEM: SO... GAMBLING?", "THEM: SOUNDS LIKE A SCAM", "THEM: JUST USE BANKS", "THEM: IS IT LEGAL?"],
                wholesome: ["THEM: I'M TRYING TO UNDERSTAND ‚ù§Ô∏è", "THEM: TELL ME MORE!", "THEM: YOU'RE SO SMART", "THEM: THAT'S INTERESTING"],
                dark: ["THEM: *SOUL LEAVES BODY*", "THEM: MAKE IT STOP", "THEM: I REGRET ASKING", "THEM: HELP"],
                absurd: ["THEM: *CONFUSED SCREAMING*", "THEM: WHAT", "THEM: ERROR", "THEM: BRAIN HURTY"],
                smart: ["THEM: *PROCESSING*", "THEM: FASCINATING", "THEM: CONTINUE", "THEM: INTRIGUING HYPOTHESIS"]
            };
            
            const styleReactions = reactions[style] || reactions.classic;
            return styleReactions[Math.floor(Math.random() * styleReactions.length)];
        }
        
        /**
         * Generate waiting setup
         */
        function generateWaitingSetup(input, keywords) {
            const setups = [
                "DAY 1 OF WAITING:",
                "STILL WAITING FOR:",
                "BEEN WAITING SINCE:",
                "PATIENTLY WAITING FOR:"
            ];
            
            let core = input.replace(/waiting\s+(for\s+)?/i, '').replace(/wait\s+(for\s+)?/i, '').trim();
            return setups[Math.floor(Math.random() * setups.length)] + " " + core.toUpperCase();
        }
        
        /**
         * Generate waiting punchline
         */
        function generateWaitingPunchline(style, theme) {
            if (theme === 'crypto') {
                return ["STILL WAITING", "ANY DAY NOW", "SOON‚Ñ¢", "2 MORE WEEKS"][Math.floor(Math.random() * 4)];
            }
            return ["PATIENCE LEVEL: 0", "STILL WAITING", "ANY MINUTE NOW", "NARRATOR: THEY'RE STILL WAITING"][Math.floor(Math.random() * 4)];
        }
        
        /**
         * Generate unprompted actions
         */
        function generateUnpromptedAction(keywords, theme) {
            if (theme === 'crypto') {
                return ["*CHECKS PORTFOLIO*", "*SHILLS RANDOM COIN*", "*DRAWS LINES ON CHART*", "*CALCULATES MOON PRICE*"][Math.floor(Math.random() * 4)];
            }
            return ["*DOES THE THING*", "*OVERSHARES*", "*RANDOM THOUGHT*", "*UNNECESSARY COMMENT*"][Math.floor(Math.random() * 4)];
        }
        
        /**
         * Transform generic input
         */
        function transformGenericInput(input, keywords, theme) {
            // Split input intelligently
            const words = input.split(/\s+/);
            
            // If input is short, add context
            if (words.length <= 3) {
                return {
                    top: "POV: " + input.toUpperCase(),
                    bottom: generateReaction('neutral', 'classic', theme)
                };
            }
            
            // If input is long, extract core and add punchline
            const midpoint = Math.ceil(words.length / 2);
            const firstHalf = words.slice(0, midpoint).join(' ');
            const secondHalf = words.slice(midpoint).join(' ');
            
            return {
                top: firstHalf.toUpperCase(),
                bottom: secondHalf.toUpperCase() + " üíÄ"
            };
        }
        
        /**
         * Apply style-specific modifiers
         */
        function applyStyleModifiers(top, bottom, style, theme) {
            // Add style-specific emojis or modifications
            const modifiers = {
                crypto: { emoji: 'üíé', suffix: '' },
                wholesome: { emoji: '‚ù§Ô∏è', suffix: '' },
                dark: { emoji: 'üíÄ', suffix: '' },
                absurd: { emoji: 'ü§™', suffix: ' (REAL)' },
                smart: { emoji: 'üß†', suffix: '' },
                classic: { emoji: 'üòÇ', suffix: '' }
            };
            
            const mod = modifiers[style] || modifiers.classic;
            
            return {
                top: top,
                bottom: bottom + mod.suffix
            };
        }
        
        /**
         * Stage 4: Validate that output is different from input
         */
        function validateUniqueness(memeText, originalInput) {
            const { top, bottom } = memeText;
            const combined = (top + " " + bottom).toLowerCase();
            const original = originalInput.toLowerCase();
            
            // If output is too similar to input, add more transformation
            if (combined === original || top.toLowerCase() === original) {
                return {
                    top: "POV: " + top,
                    bottom: bottom + " (REAL)"
                };
            }
            
            return memeText;
        }
        
        // ============================================
        // MEME GENERATION FUNCTIONS
        // ============================================
        
        function generateMeme() {
            const input = document.getElementById('userInput').value.trim();
            
            if (!input) {
                alert('‚ö†Ô∏è Please enter some text first!');
                return;
            }
            
            lastInput = input;
            
            // Show loading and processing info
            document.getElementById('loading').classList.add('active');
            document.querySelector('.canvas-container canvas').style.opacity = '0.3';
            document.getElementById('processingInfo').style.display = 'block';
            
            // Simulate AI processing steps
            const steps = [
                'üîç Analyzing input...',
                'üß† Understanding context...',
                'üí° Generating comedy...',
                '‚ú® Applying style...',
                '‚úÖ Meme ready!'
            ];
            
            let stepIndex = 0;
            const stepInterval = setInterval(() => {
                if (stepIndex < steps.length) {
                    document.getElementById('processingSteps').textContent = steps[stepIndex];
                    stepIndex++;
                } else {
                    clearInterval(stepInterval);
                }
            }, 300);
            
            setTimeout(() => {
                // Process through AI engine
                const memeText = intelligentMemeProcessor(input, currentStyle);
                lastOutput = { top: memeText.top, bottom: memeText.bottom };
                
                // Draw the meme
                drawMeme(memeText.top, memeText.bottom, currentStyle);
                
                // Hide loading
                document.getElementById('loading').classList.remove('active');
                document.querySelector('.canvas-container canvas').style.opacity = '1';
                
                setTimeout(() => {
                    document.getElementById('processingInfo').style.display = 'none';
                }, 2000);
            }, 1500);
        }
        
        function drawMeme(topText, bottomText, style) {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Choose background based on style
            const backgrounds = {
                classic: { gradient: ['#FFE5E5', '#E5FFE5'], emoji: 'üòÇ' },
                crypto: { gradient: ['#667eea', '#764ba2'], emoji: 'üíé' },
                wholesome: { gradient: ['#FFE5F0', '#FFF0E5'], emoji: 'ü•∞' },
                dark: { gradient: ['#2C3E50', '#34495E'], emoji: 'üòà' },
                absurd: { gradient: ['#FF6B6B', '#FFE66D'], emoji: 'ü§™' },
                smart: { gradient: ['#4ECDC4', '#44A08D'], emoji: 'üß†' }
            };
            
            const bg = backgrounds[style] || backgrounds.classic;
            
            // Draw gradient background
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, bg.gradient[0]);
            gradient.addColorStop(1, bg.gradient[1]);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add decorative elements
            ctx.font = '120px Arial';
            ctx.fillText(bg.emoji, 50, 150);
            ctx.fillText(bg.emoji, canvas.width - 150, canvas.height - 50);
            
            // Draw text with better styling
            ctx.fillStyle = 'white';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 8;
            ctx.font = 'bold 60px Impact, Arial Black, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            // Top text
            const topLines = wrapText(topText, canvas.width - 100);
            let topY = 100;
            topLines.forEach(line => {
                ctx.strokeText(line, canvas.width / 2, topY);
                ctx.fillText(line, canvas.width / 2, topY);
                topY += 70;
            });
            
            // Bottom text
            const bottomLines = wrapText(bottomText, canvas.width - 100);
            let bottomY = canvas.height - (bottomLines.length * 70) - 100;
            bottomLines.forEach(line => {
                ctx.strokeText(line, canvas.width / 2, bottomY);
                ctx.fillText(line, canvas.width / 2, bottomY);
                bottomY += 70;
            });
            
            // Add IDIOT watermark
            ctx.font = 'bold 24px Arial';
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.strokeStyle = 'rgba(0,0,0,0.3)';
            ctx.lineWidth = 2;
            ctx.textAlign = 'right';
            ctx.strokeText('IDIOT TOKEN', canvas.width - 20, canvas.height - 20);
            ctx.fillText('IDIOT TOKEN', canvas.width - 20, canvas.height - 20);
        }
        
        function wrapText(text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';
            
            words.forEach(word => {
                const testLine = currentLine + (currentLine ? ' ' : '') + word;
                const metrics = ctx.measureText(testLine);
                
                if (metrics.width > maxWidth && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            });
            
            if (currentLine) {
                lines.push(currentLine);
            }
            
            return lines;
        }
        
        function regenerateMeme() {
            if (lastInput) {
                generateMeme();
            }
        }
        
        function downloadMeme() {
            const link = document.createElement('a');
            link.download = `idiot-meme-${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png', 1.0);
            link.click();
        }
        
        function copyMeme() {
            canvas.toBlob(blob => {
                navigator.clipboard.write([
                    new ClipboardItem({ 'image/png': blob })
                ]).then(() => {
                    alert('‚úÖ Meme copied to clipboard!');
                }).catch(() => {
                    alert('‚ùå Failed to copy. Try downloading instead.');
                });
            });
        }
        
        function shareTwitter() {
            const text = encodeURIComponent(`Just made this with the IDIOT Meme Generator! üß†\n\nTop: ${lastOutput.top}\nBottom: ${lastOutput.bottom}\n\n#IDIOTToken #MemeGenerator`);
            window.open(`https://twitter.com/intent/tweet?text=${text}&url=${encodeURIComponent('https://stupidiots.com')}`, '_blank');
        }
        
        function shareTelegram() {
            const text = encodeURIComponent(`Check out my IDIOT meme! üß†`);
            window.open(`https://t.me/share/url?url=${encodeURIComponent('https://stupidiots.com')}&text=${text}`, '_blank');
        }
        
        function shareReddit() {
            const title = encodeURIComponent(`My IDIOT Token Meme`);
            window.open(`https://reddit.com/submit?url=${encodeURIComponent('https://stupidiots.com')}&title=${title}`, '_blank');
        }
        
        function shareDiscord() {
            copyMeme();
            alert('üìã Meme copied! Paste it in Discord.');
        }
        
        function shareWhatsApp() {
            const text = encodeURIComponent(`Check out my IDIOT meme! üß†`);
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            const url = isMobile 
                ? `whatsapp://send?text=${text}`
                : `https://web.whatsapp.com/send?text=${text}`;
            window.open(url, '_blank');
        }
        
        function useExample(text) {
            document.getElementById('userInput').value = text;
            generateMeme();
        }
        
        // Generate initial meme
        window.onload = () => {
            document.getElementById('userInput').value = "I bought crypto at the all-time high";
            generateMeme();
        };
    </script>
</body>
</html>
